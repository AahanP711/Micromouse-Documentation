 The Depth-First Search (DFS) algorithm is a graph traversal and search algorithm that systematically explores a graph or tree structure by **prioritizing depth over breadth**. Its operational principle involves traversing as far as possible along each branch before backtracking. This is intrinsically managed through the use of a **stack data structure**, either explicitly implemented or implicitly by the call stack during recursive function calls.
![[Depth-First-Tree-Traversal.gif]]

When initiated from a starting node, DFS proceeds by selecting an unvisited adjacent node, pushing the current node onto the stack, and then recursively or iteratively moving to the newly selected node. This process continues until a node with no unvisited neighbors (a "dead end" in the context of a maze, or a leaf node in a tree) is reached. At this point, the algorithm **backtracks** by popping nodes from the stack until it finds a node with an unexplored branch. To prevent infinite loops in cyclic graphs and redundant computations, DFS maintains a set of **visited nodes**. Before exploring a node, it checks if it has already been visited; if so, it skips that branch.

 **Computational complexity standpoint**, for a graph with V vertices and E edges, DFS typically has a time complexity of O(V+E) when implemented with an adjacency list, as each vertex and edge is visited at most once. The space complexity is O(V) in the worst case, corresponding to the maximum depth of the recursion stack or the size of the explicit stack, which can be significant for deep, narrow graphs. While effective for tasks like cycle detection, topological sorting, or finding _any_ path between two nodes, DFS does not guarantee the shortest path in unweighted graphs, unlike Breadth-First Search (BFS), due to its depth-first exploration bias.