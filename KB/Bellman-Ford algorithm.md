The **Bellman-Ford algorithm** is a **heavy-duty workhorse** in the realm of shortest path algorithms, specifically designed to find the shortest paths from a single source vertex to all other vertices in a **weighted graph**. Its distinguishing feature, and where it **flexes its muscles** over [[Dijkstra's algorithm]], is its **unflinching ability to handle graphs with _negative edge weights_**.

![[bellman.gif]]
The core principle is **iterative relaxation**. It doesn't greedily pick the "best" path immediately. Instead, it systematically **over-estimates** the distance to all vertices (except the source, which is 0) and then **iteratively reduces** these estimates. For a graph with V vertices and E edges, it performs V−1 passes. In each pass, it **scans _all_ edges** in the graph. For every edge (u,v) with weight w, if the current shortest distance to u plus w is less than the current shortest distance to v, it **relaxes** the edge by updating v's distance. This repeated relaxation ensures that shortest paths propagate through the graph, even when negative weights are involved.

A **critical byproduct** of this iterative approach is its capacity for **negative cycle detection**. After V−1 passes, if a further V-th pass reveals that any edge can still be relaxed, it definitively indicates the presence of a **negative cycle reachable from the source**. This is a scenario where a path's total weight can decrease indefinitely, rendering a true "shortest path" undefined. While its time complexity of O(V⋅E) makes it slower than Dijkstra's for graphs with only non-negative weights, its **robustness against negative weights and its cycle detection capability** secure its place as an indispensable tool in network routing, arbitrage detection, and other complex graph problems.